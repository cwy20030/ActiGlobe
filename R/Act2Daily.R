#  File ActiGlobe/R/Act2Daily.R
#
#  Copyright (C) 2025  C. William Yao, PhD
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#
#' @title Split and Annotate Actigraphy Data into Daily Records
#'
#' @description
#' `Act2Daily` is used to split the actigraphy recording by the recording dates stored in Bdf (a BriefSum object).
#'
#' @note
#' When you cross into a time zone with a larger UTC offset (e.g., Montreal \eqn{UTC-5} to Taipei \eqn{UTC+8}), it will generate a small overlap of epochs between the day
#' before travel and the day labeled "Travel Day" in the "Daily_df". Conversely,
#' when you move into a time zone with a smaller UTC offset, a brief gap appears
#' on "Travel Day", with labeling - "Unallocated", which represents "time lose".
#'
#'
#' @details Transforms a continuous actigraphy time-series into a day-by-day list
#'  of aligned epoch and produces a fully annotated data frame. Based on the
#'  summary table generated by either \code{\link{BriefSum}} or \code{\link{TAdjust}}, it re-organize and
#'  segment the raw recording data by each day. The function is designed to
#'  process incomplete recordings while accounting for travel and daylight-saving
#'  adjustments. All labels contained in the summary table (i.e., Bdf) will be
#'  assigned to the corresponding data points. This workflow ensures that each day's recording is bounded by its
#'  calendar date while accounts for travel--induced overlaps, and clearly documents any incomplete or unallocated points.
#'
#'
#' @param df A data.frame of raw actigraphy recording. Both time and activity count
#' should be included in the `df`. See `VAct` and `VTm` for further detail.
#' @param Bdf A \code{\link{BriefSum}} object containing per-day metadata for the recording. Note, if jet lag occurred during the recording, please, update the metadata using \code{\link{TAdjust}} before passing to this function.
#' @param TUnit Character; time--unit for the x--axis of each day's timeline.
#'   Must be one of `day`, `hour`, `minute` or `second`.  Default is `hour`.
#' @param VAct Optional character. Name of the activity column in `df`. If NULL,
#'   defaults to the second column of `df`.
#' @param VTm Optional character.  Name of the time index column in `df`. If NULL,
#'   defaults to the first column of `df`.
#' @param Incomplete Logical; if TRUE, days flagged `Incomplete Recording` (i.e. <24 h)
#'   are retained in the data list with recordings segmented by day. Default = FALSE (these days are removed).
#' @param Travel Logical; if TRUE, days flagged `Travel` are retained although
#'   some data points from an earlier adjacent calendar day may be duplicated (a
#'   warning is issued). If FALSE, travel days and the day before/after are excluded.
#'   Default = TRUE.
#'
#'
#' @returns A data list that includes the adjusted recordings both in long format and as a nested list by day.
#'
#'
#' @seealso \code{\link{TAdjust}} \code{\link{write.act}}
#'
#' @examples
#' \dontrun{
#'
#' # Import data
#' data (FlyEast)
#'
#'
#' # Create quick summary of the recording with adjustment for daylight saving.
#' BdfList <-
#'     BriefSum (
#'         df = FlyEast,
#'         SR = 1 / 60,
#'         Start = "2017-10-24 13:45:00"
#'     )
#'
#'
#' # Lets extract the quick summary of the recording
#' Bdf <- BdfList$Bdf
#'
#' ### Note that since the original data was affected by travel-induced time
#' ### shift, the recordings would not be properly segmented from 2017-11-02.
#'
#' ## To avoid time shift due to travelling, we will keep only the first 8 days.
#' Bdf <- Bdf [1:8, ]
#' df <- BdfList$df
#'
#' # Segment Data by Day
#' dfList <-
#'     Act2Daily (
#'         df = df,
#'         Bdf = Bdf,
#'         VAct = "Activity",
#'         VTm = "Time",
#'         Incomplete = TRUE,
#'         Travel = TRUE
#'     )
#'
#' str (dfList) ### Look at the output structure
#' View (dfList)
#' }
#'
#' @keywords Daily Actigraphy Segment
#' @export

Act2Daily <- function (df, Bdf, TUnit = "hour", VAct = NULL, VTm = NULL,
                       Incomplete = FALSE, Travel = TRUE) {

    # Extract essential per-day metadata from Bdf -------------------
    IANA <- get0("IANA", envir = asNamespace("ActiGlobe")) # Time zone database
    iTZ <- IANA$Timezone_IANA
    STD <- IANA$TZ_Code


    DT <- Bdf$Date # Calendar date for each recording day

    aTZ <- sapply (Bdf$TZ_code, function (x) { # Time zone identifier per day
       iTZ [STD %in% x] [1]
    })


    Epc <- Bdf$Epoch # Epoch length (seconds) per day
    UTCs <- Bdf$UTC # UTC offset for each day
    DSTs <- Bdf$Daylight_Saving # Daylight saving flag per day

    # Cumulative recording seconds at start/end to convert to epoch indices
    a <- Bdf$Cumulative_Start_Second # Seconds from midnight to first data point
    b <- Bdf$Cumulative_End_Second # Seconds from midnight to last data point
    iDP <- a / Epc # Starting epoch index (1-based)
    eDP <- b / Epc # Ending epoch index (1-based)

    # Recording boundary times as strings
    RS <- Bdf$Recording_Start # e.g. "HH:MM:SS" for day start
    RE <- Bdf$Recording_End # e.g. "HH:MM:SS" for day end
    DRS <- paste0 (DT, " ", RS) # Full datetime at recording start
    DRE <- paste0 (DT, " ", RE) # Full datetime at recording end


    ## Determine divider to convert seconds into requested TUnit --------------

    TDivider <- ifelse (
        TUnit == "day", 24 * 3600,
        ifelse (TUnit == "hour", 3600,
            ifelse (TUnit == "minute", 60,
                ifelse (TUnit == "second", 1, NA)
            )
        )
    )

    # If an invalid TUnit was provided, prompt user to choose one
    if (is.na (TDivider)) {
        TUnit <- Demand (c ("day", "hour", "minute", "second"), "Time Unit")
        TDivider <- ifelse (
            TUnit == "day", 24 * 3600,
            ifelse (TUnit == "hour", 3600,
                ifelse (TUnit == "minute", 60,
                    ifelse (TUnit == "second", 1, NA)
                )
            )
        )
    }


    ## Set default variable names for activity and time columns ----------------

    if (is.null (VAct)) VAct <- names (df) [[2]] # Default: second column of df
    if (is.null (VTm)) VTm <- names (df) [[1]] # Default: first column of df


    if (!inherits (df [[VAct]], "numeric")) df [[VAct]] <- as.numeric (as.character (df [[VAct]]))
    if (all (df [[VAct]] == 0)) stop ("all activity values are zero")
    if (any (!is.finite (df [[VAct]]))) stop ("activity contains NA/NaN/Inf")
    if (!inherits (df [[VTm]], "numeric")) df [[VTm]] <- C2T (df [[VTm]])


    ## Build warning & exclusion masks -------------------------

    W <- Bdf$Warning # Warning label per day
    Ecl <- Bdf$Excluded # Logical: exclude this day?
    fDP <- max (Bdf$nDataPoints, na.rm = TRUE) # Max points in a full day

    # Optionally keep "Incomplete Recording" days
    if (Incomplete) {
        Ecl [W == "Incomplete Recording"] <- FALSE
    }

    # Handle travel days: keep if Travel=TRUE, else exclude
    if (Travel) {
        Ecl [grep ("Travel", W)] <- FALSE
        warning ("Due to travel, some activity counts will overlap spanning adjacent days!")
    } else {
        Ecl [grep ("Travel", W)] <- TRUE
    }


    ## Initialize output list structure (one element per date) ------------

    Out <- rep (list (list ()), length (DT))
    names (Out) <- DT # Use each date string as list element name


    ## Identify which df columns were not generated by ActiGlobe --------------

    VNames <- names (df)
    VNames <- VNames [!VNames %in%
        c ("DateTime", "Date", "Time", "UTC", "DaylightSaving", "nPoint", "Note")]


    ## Main loop: slice, align and annotate each calendar day ----------------

    for (d in seq_along (DT)) {

        # Convert current date to character and POSIX numeric
        D <- as.character (DT [[d]])
        D.num <- as.numeric (as.POSIXct (D, tz = aTZ [[d]]))

        # Compute start/end epoch indices for this day
        S <- a [[d]] / Epc [[d]]
        E <- b [[d]] / Epc [[d]]

        # Parse full POSIXct start/end datetimes
        rs <- as.POSIXct (DRS [d], tz = aTZ [[d]])
        re <- as.POSIXct (DRE [d], tz = aTZ [[d]])
        nrs <- as.numeric (rs)
        nre <- as.numeric (re)

        # Generate a continuous vector of epoch--timestamps
        YMDHMS <- seq (from = nrs, to = nre, by = Epc [[d]])
        AllT <- as.POSIXct (YMDHMS, tz = aTZ [[d]])

        # Compute time offset from midnight (in chosen TUnit)
        Time <- (YMDHMS - D.num) / TDivider

        # Extract the raw df rows for this day's epochs
        Temp <- df [S:E, VNames]

        # Add new columns for timeline and metadata
        Temp [[VTm]] <- Time
        Temp$YMDHMS <- AllT
        Temp$Date <- D
        Temp$Time <- format (AllT, "%H:%M:%S")
        Temp$UTC <- UTCs [[d]]
        Temp$DST <- DSTs [[d]]
        Temp$Act_ID <- seq (S, E) # Original epoch index
        Temp$Note <- Bdf [d, "Warning"] # Day's warning label

        # Reorder to consistent column layout
        Temp <- Temp [c (
            VNames, "YMDHMS", "Date", "Time",
            "UTC", "DST", "Act_ID", "Note"
        )]


        ### If first day's recording starts after midnight, prepend empty rows
        if (d == 1 && S > 1) {
            # How many epochs missing before first measure?
            ERows <- fDP - (1 + (b [[d]] - a [[d]]) / Epc [[d]])

            # Create blank template for missing epochs
            TmpDf <- as.data.frame (
                matrix (NA, nrow = ERows, ncol = ncol (Temp))
            )
            names (TmpDf) <- names (Temp)

            # Generate timestamps from midnight to first epoch
            YMDHMS2 <- seq (from = D.num, to = nrs, by = Epc [[d]])
            YMDHMS2 <- YMDHMS2 [-length (YMDHMS2)] # drop overlap point
            AllT2 <- as.POSIXct (YMDHMS2, tz = aTZ [[d]])
            Time2 <- (YMDHMS2 - D.num) / TDivider

            # Fill blank template with "No Measure" metadata
            TmpDf$YMDHMS <- AllT2
            TmpDf [[VTm]] <- Time2
            TmpDf$Date <- D
            TmpDf$Time <- format (AllT2, "%H:%M:%S")
            TmpDf$UTC <- UTCs [[d]]
            TmpDf$DST <- DSTs [[d]]
            TmpDf$Note <- "No Measure"

            # Prepend to daily Temp
            Temp <- rbind (TmpDf, Temp)
        }


        ### Finalize column names and store in Out (unless excluded)

        names (Temp) <- c (VNames, "DateTime", "Date", "Time", "UTC", "DaylightSaving", "nPoint", "Note")
        Temp$DateTime <- paste0 (as.character (Temp$Date), " ", as.character (Temp$Time))


        if (!Ecl [d]) {
            Out [[D]] <- Temp
        } else {
            Out [[D]] <- list () # keep empty for excluded days
        }
    }

    ##  Recombine, remove overlap, and flag unallocated epochs -----------------

    df3 <- do.call (rbind, Out)
    df3.5 <- df3 [!duplicated (df3$nPoint), ]
    df3.5 <- subset (df3.5, !is.na (df3.5$nPoint))

    oNP <- df$nPoint
    nNP <- df3.5$nPoint
    mNP <- oNP [!oNP %in% nNP] # original points never reassigned

    ndf <- df
    # ndf[[VTm]]   = C2T(ndf[[VTm]])  ### Will crash R Studio
    ndf$Note <- ""

    VNames2 <- names (df) [names (df) %in% names (Temp)]
    ndf [ndf$nPoint %in% nNP, VNames2] <- df3.5 [VNames2]
    ndf [ndf$nPoint %in% mNP, "Note"] <- "Unallocated"


    ## Return a list: per-day data and the full annotated df -----------------

    return (list (
        "Daily_df" = Out,
        "df"       = ndf
    ))
}
