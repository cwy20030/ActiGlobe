#  File ActiGlobe/R/Act2Daily.R
#
#  Copyright (C) 2025  C. William Yao, PhD
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
#' @title Split and Annotate Actigraphy Data into Daily Records
#' @description
#' `Act2Daily` is used to split the actigraphy recording by the recording dates stored in Bdf (a BriefSum object).
#'
#' @note
#' When you cross into a time zone with a larger UTC offset (e.g., Montreal \eqn{UTC-5} to Taipei \eqn{UTC+8}), it will generate a small overlap of epochs between the day
#' before travel and the day labeled "Travel Day" in the "Daily_df". Conversely,
#' when you move into a time zone with a smaller UTC offset, a brief gap appears
#' on "Travel Day", with labeling - "Unallocated", which represents "time lose".
#'
#' @details Transforms a continuous actigraphy time-series into a day-by-day list
#'  of aligned epoch and produces a fully annotated data frame. Based on the
#'  summary table generated by either \code{\link{BriefSum}} or \code{\link{TAdjust}}, it re-organize and
#'  segment the raw recording data by each day. The function is designed to
#'  process incomplete recordings while accounting for travel and daylight-saving
#'  adjustments. All labels contained in the summary table (i.e., Bdf) will be
#'  assigned to the corresponding data points. This workflow ensures that each day's recording is bounded by its
#'  calendar date while accounts for travel--induced overlaps, and clearly documents any incomplete or unallocated points.
#'
#' @param df A data.frame of raw actigraphy recording. Both time and activity count
#' should be included in the `df`. See `VAct` and `VTm` for further detail.
#' @param Bdf A BriefSum object. If jet lag or daylight saving occurred during the recording,
#'   please, use the updated version from \code{\link{TAdjust}}.
#' @param TUnit Character; time--unit for the x--axis of each day's timeline.
#'   Must be one of `day`, `hour`, `minute` or `second`.  Default is `hour`.
#' @param VAct Optional character.  Name of the activity column in `df`. If NULL,
#'   defaults to the second column of `df`.
#' @param VTm Optional character.  Name of the time index column in `df`. If NULL,
#'   defaults to the first column of `df`.
#' @param Incomplete Logical; if TRUE, days flagged `Incomplete Recording` (i.e. <24 h)
#'   are retained in the data list with recordings segmented by day. Default = FALSE (these days are removed).
#' @param Travel Logical; if TRUE, days flagged `Travel` are retained although
#'   some data points from an earlier adjacent calendar day may be duplicated (a
#'   warning is issued). If FALSE, travel days and the day before/after are excluded.
#'   Default = TRUE.
#'
#' @returns A data list that includes the adjusted recordings both in long format and as a nested list by day.
#'
#' @examples
#'
#' \dontrun{
#'
#' # Import data
#' data(FlyEast)
#'
#'
#' # Create quick summary of the recording with adjustment for daylight saving.
#' BdfList <-
#' BriefSum(df = FlyEast ,
#'          SR = 1/60,
#'          Start = "2017-10-24 13:45:00")
#'
#'
#'  # Let's extract the quick summary of the recording
#' Bdf <- BdfList$Bdf
#'
#' ### Note that since the original data was affected by travel-induced time
#' ### shift, the recordings would not be properly segmented from 2017-11-02.
#'
#' ## To avoid time shift due to travelling, we will keep only the first 8 days.
#' Bdf <- Bdf[1:8,]
#'
#'
#' # Segment Data by Day
#' dfList =
#'  Act2Daily(df = FlyEast,
#'            Bdf = Bdf,
#'            VAct = "Activity",
#'            VTm = "X2",
#'            Incomplete = TRUE,
#'            Travel = TRUE)
#'
#' str(dfList) ### Look at the output structure
#' View(dfList)
#'
#'
#' }
#' @seealso \code{\link{TAdjust}} \code{\link{write.act}}
#' @keywords Daily Actigraphy Segment
#' @export

Act2Daily <- function(df, Bdf, TUnit = "hour", VAct = NULL, VTm = NULL,
                      Incomplete = FALSE, Travel = TRUE) {
  ## ---------------------------------------------------------------------------
  ## 1. Extract essential per-day metadata from Bdf
  ## ---------------------------------------------------------------------------
  DT    = Bdf$Date                   # Calendar date for each recording day
  aTZ   = Bdf$TZ_code                # Time zone identifier per day
  Epc   = Bdf$Epoch                  # Epoch length (seconds) per day
  UTCs  = Bdf$UTC                    # UTC offset for each day
  DSTs  = Bdf$Daylight_Saving        # Daylight saving flag per day

  # Cumulative recording seconds at start/end to convert to epoch indices
  a     = Bdf$Cumulative_Start_Second  # Seconds from midnight to first data point
  b     = Bdf$Cumulative_End_Second    # Seconds from midnight to last data point
  iDP   = a / Epc                       # Starting epoch index (1-based)
  eDP   = b / Epc                       # Ending epoch index (1-based)

  # Recording boundary times as strings
  RS    = Bdf$Recording_Start        # e.g. "HH:MM:SS" for day start
  RE    = Bdf$Recording_End          # e.g. "HH:MM:SS" for day end
  DRS   = paste0(DT, " ", RS)        # Full datetime at recording start
  DRE   = paste0(DT, " ", RE)        # Full datetime at recording end

  ## ---------------------------------------------------------------------------
  ## 2. Determine divider to convert seconds into requested TUnit
  ## ---------------------------------------------------------------------------
  TDivider = ifelse(
    TUnit == "day",    24 * 3600,
    ifelse(TUnit == "hour", 3600,
           ifelse(TUnit == "minute", 60,
                  ifelse(TUnit == "second", 1, NA)
           )
    )
  )

  # If an invalid TUnit was provided, prompt user to choose one
  if (is.na(TDivider)) {
    TUnit     = Demand(c("day", "hour", "minute", "second"), "Time Unit")
    TDivider  = ifelse(
      TUnit == "day",    24 * 3600,
      ifelse(TUnit == "hour", 3600,
             ifelse(TUnit == "minute", 60,
                    ifelse(TUnit == "second", 1, NA)
             )
      )
    )
  }

  ## ---------------------------------------------------------------------------
  ## 3. Set default variable names for activity and time columns
  ## ---------------------------------------------------------------------------
  if (is.null(VAct)) VAct = names(df)[[2]]  # Default: second column of df
  if (is.null(VTm))  VTm  = names(df)[[1]]  # Default: first column of df

  ## ---------------------------------------------------------------------------
  ## 4. Build warning & exclusion masks
  ## ---------------------------------------------------------------------------
  W   = Bdf$Warning                      # Warning label per day
  Ecl = Bdf$Excluded                     # Logical: exclude this day?
  fDP = max(Bdf$nDataPoints, na.rm = TRUE)  # Max points in a full day

  # Optionally keep "Incomplete Recording" days
  if (Incomplete) {
    Ecl[W == "Incomplete Recording"] = FALSE
  }

  # Handle travel days: keep if Travel=TRUE, else exclude
  if (Travel) {
    Ecl[grep("Travel", W)] = FALSE
    warning("Due to travel, some activity counts will overlap spanning adjacent days!")
  } else {
    Ecl[grep("Travel", W)] = TRUE
  }

  ## ---------------------------------------------------------------------------
  ## 5. Initialize output list structure (one element per date)
  ## ---------------------------------------------------------------------------
  Out = rep(list(list()), length(DT))
  names(Out) = DT  # Use each date string as list element name

  ## ---------------------------------------------------------------------------
  ## 6. Identify which df columns were not generated by ActiGlobe
  ## ---------------------------------------------------------------------------
  VNames = names(df)
  VNames = VNames[!VNames %in%
                    c("DateTime","Date","Time","UTC","DaylightSaving","nPoint","Note") ]

  ## ---------------------------------------------------------------------------
  ## 7. Main loop: slice, align and annotate each calendar day
  ## ---------------------------------------------------------------------------
  for (d in seq_along(DT)) {

    # Convert current date to character and POSIX numeric
    D     = as.character(DT[[d]])
    D.num = as.numeric(as.POSIXct(D, tz = aTZ[[d]]))

    # Compute start/end epoch indices for this day
    S = a[[d]] / Epc[[d]]
    E = b[[d]] / Epc[[d]]

    # Parse full POSIXct start/end datetimes
    rs  = as.POSIXct(DRS[d], tz = aTZ[[d]])
    re  = as.POSIXct(DRE[d], tz = aTZ[[d]])
    nrs = as.numeric(rs)
    nre = as.numeric(re)

    # Generate a continuous vector of epoch--timestamps
    YMDHMS = seq(from = nrs, to = nre, by = Epc[[d]])
    AllT   = as.POSIXct(YMDHMS, tz = aTZ[[d]])

    # Compute time offset from midnight (in chosen TUnit)
    Time = (YMDHMS - D.num) / TDivider

    # Extract the raw df rows for this day's epochs
    Temp = df[S:E, VNames]

    # Add new columns for timeline and metadata
    Temp[[VTm]]  = Time
    Temp$YMDHMS  = AllT
    Temp$Date    = D
    Temp$Time    = format(AllT, "%H:%M:%S")
    Temp$UTC     = UTCs[[d]]
    Temp$DST     = DSTs[[d]]
    Temp$Act_ID  = seq(S, E)           # Original epoch index
    Temp$Note    = Bdf[d, "Warning"]   # Day's warning label

    # Reorder to consistent column layout
    Temp = Temp[c(VNames, "YMDHMS", "Date", "Time",
                  "UTC", "DST", "Act_ID", "Note")]

    ## -------------------------------------------------------------------------
    ## 7a. If first day's recording starts after midnight, prepend empty rows
    ## -------------------------------------------------------------------------
    if (d == 1 && S > 1) {
      # How many epochs missing before first measure?
      ERows = fDP - (1 + (b[[d]] - a[[d]]) / Epc[[d]])

      # Create blank template for missing epochs
      TmpDf = as.data.frame(
        matrix(NA, nrow = ERows, ncol = ncol(Temp))
      )
      names(TmpDf) = names(Temp)

      # Generate timestamps from midnight to first epoch
      YMDHMS2  = seq(from = D.num, to = nrs, by = Epc[[d]])
      YMDHMS2  = YMDHMS2[-length(YMDHMS2)]  # drop overlap point
      AllT2    = as.POSIXct(YMDHMS2, tz = aTZ[[d]])
      Time2    = (YMDHMS2 - D.num) / TDivider

      # Fill blank template with "No Measure" metadata
      TmpDf$YMDHMS = AllT2
      TmpDf[[VTm]] = Time2
      TmpDf$Date   = D
      TmpDf$Time   = format(AllT2, "%H:%M:%S")
      TmpDf$UTC    = UTCs[[d]]
      TmpDf$DST    = DSTs[[d]]
      TmpDf$Note   = "No Measure"

      # Prepend to daily Temp
      Temp = rbind(TmpDf, Temp)
    }

    ## -------------------------------------------------------------------------
    ## 7b. Finalize column names and store in Out (unless excluded)
    ## -------------------------------------------------------------------------
    names(Temp) = c(VNames, "DateTime", "Date", "Time", "UTC", "DaylightSaving", "nPoint", "Note")
    Temp$DateTime = paste0(as.character(Temp$Date), " ", as.character(Temp$Time))


    if (!Ecl[d]) {
      Out[[D]] = Temp
    } else {
      Out[[D]] = list()   # keep empty for excluded days
    }
  }

  ## ---------------------------------------------------------------------------
  ## 8. Recombine, remove overlap, and flag unallocated epochs
  ## ---------------------------------------------------------------------------
  df3    = do.call(rbind, Out)
  df3.5  = df3[!duplicated(df3$nPoint), ]
  df3.5  = subset(df3.5, !is.na(df3.5$nPoint))

  oNP    = df$nPoint
  nNP    = df3.5$nPoint
  mNP    = oNP[!oNP %in% nNP]  # original points never reassigned

  ndf          = df
  # ndf[[VTm]]   = C2T(ndf[[VTm]])  ### Will crash R Studio
  ndf$Note     = ""

  VNames2 <- names(df)[names(df) %in%  names(Temp)]
  ndf[ndf$nPoint %in% nNP, VNames2]   = df3.5[VNames2]
  ndf[ndf$nPoint %in% mNP, "Note"]   = "Unallocated"


  ## ---------------------------------------------------------------------------
  ## 9. Return a list: per-day data and the full annotated df
  ## ---------------------------------------------------------------------------
  return(list(
    "Daily_df" = Out,
    "df"       = ndf
  ))
}

